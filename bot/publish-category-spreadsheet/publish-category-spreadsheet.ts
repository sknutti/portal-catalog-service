import { CatalogResolver } from '@bot/publish-category-spreadsheet/catalog-resolver';
import { keyWith, UnexpectedError } from '@dsco/ts-models';
import { CoreCatalog } from '@lib/core-catalog';
import { getDscoEnv, getFanaticsBucketName, getIsRunningLocally } from '@lib/environment';
import { getFanaticsAccountForEnv } from '@lib/fanatics';
import {
    CatalogSpreadsheetS3Metadata,
    downloadS3Bucket,
    downloadS3Metadata,
    parseCatalogItemS3UploadUrl,
    writeS3Object
} from '@lib/s3';
import { DscoSpreadsheet, generateSpreadsheet, PhysicalSpreadsheet, XlsxSpreadsheet } from '@lib/spreadsheet';
import { CsvSpreadsheet } from '@lib/spreadsheet/physical-spreadsheet/csv-spreadsheet';
import { catalogItemSearch, gunzipAsync, gzipAsync, randomFloat, WarehousesLoader } from '@lib/utils';
import { batch, collect, enumerate, filter, map } from '@lib/utils/iter-tools';
import { sendWebsocketEvent } from '@lib/utils/send-websocket-event';
import type { S3CreateEvent } from 'aws-lambda';
import { Err, Ok, Result } from 'ts-results';
import { CatalogSpreadsheetWebsocketEvents } from '../../api';

export interface PublishCategorySpreadsheetEvent {
    supplierId: number;
    retailerId: number;
    userId: number;
    categoryPath: string;
    gzippedFile?: string;
    s3Path?: string;
    skippedRowIndexes?: number[];
    // Signifies this file was uploaded via a local test and should be skipped from automated processing
    isLocalTest?: boolean;
}

export async function publishCategorySpreadsheet(event: PublishCategorySpreadsheetEvent | S3CreateEvent): Promise<void> {
    if (!('supplierId' in event)){
        event = await getEventFromS3(event);
        console.log('Publish event extracted from s3 metadata: ', event);
    }

    // Ignore any s3 events generated by unit tests
    if (event.isLocalTest && !getIsRunningLocally()) {
        return;
    }

    try {
        const resp = await Promise.race([publishSpreadsheetImpl(event), timeout()] as const);
        if (resp === 'timeout') {
            throw new Error('Timeout occurred publishing spreadsheet.');
        } else if (resp.ok) {
            await sendWebsocketEvent('success', resp.val, event.supplierId);
        } else {
            await publishResultIfFanatics({success: false, error: resp.val, message: resp.val.message}, event.supplierId);

            await sendWebsocketEvent(
                'error',
                {
                    error: resp.val,
                    message: resp.val.message,
                    categoryPath: event.categoryPath,
                },
                event.supplierId,
            );
        }
    } catch (error: any) {
        await publishResultIfFanatics({success: false, error, message: 'message' in error ? error.message : 'Unexpected error',}, event.supplierId);
        await sendWebsocketEvent(
            'error',
            {
                error,
                message: 'message' in error ? error.message : 'Unexpected error',
                categoryPath: event.categoryPath,
            },
            event.supplierId,
        );
        throw error;
    }
}

async function getEventFromS3(createEvent: S3CreateEvent): Promise<PublishCategorySpreadsheetEvent> {
    console.log('Handling s3 object created: ', createEvent.Records[0]);

    let s3Path = createEvent.Records[0].s3.object.key;
    s3Path = s3Path.replace(/\+/g, ' ');
    s3Path = decodeURIComponent(s3Path);

    const meta = await downloadS3Metadata<CatalogSpreadsheetS3Metadata>(s3Path);
    const skippedRowIndexes = meta.skipped_row_indexes?.split(',').map(parseInt).filter(idx => !isNaN(idx));

    const parsed = parseCatalogItemS3UploadUrl(s3Path);
    if (parsed === 'error') {
        throw new Error(`Failed parsing catalog s3 metadata. Url: ${s3Path}`);
    }
    const {supplierId, retailerId, userId} = parsed;

    return {
        s3Path,
        skippedRowIndexes,
        supplierId,
        retailerId,
        userId,
        categoryPath: meta.category_path,
        isLocalTest: meta.is_local_test === 'true'
    };
}

async function publishSpreadsheetImpl({
    categoryPath,
    retailerId,
    supplierId,
    userId,
    gzippedFile,
    s3Path,
    skippedRowIndexes,
}: PublishCategorySpreadsheetEvent): Promise<Result<CatalogSpreadsheetWebsocketEvents['success'], UnexpectedError>> {
    const callId = Math.random().toString(36).substring(6).toUpperCase();
    console.log(`${callId} - Starting processing for supplier: ${supplierId}, path: ${s3Path}`);
    const sendProgress = (progress: number, message: string) => {
        return sendWebsocketEvent('progressUpdate', { progress, message, categoryPath }, supplierId);
    };

    const [, dscoSpreadsheet, warehouses, [supplierSpreadsheet, existingCatalogItems]] = await Promise.all([
        sendProgress(0.34, 'Parsing Spreadsheet...'),
        generateSpreadsheet(supplierId, retailerId, categoryPath),
        WarehousesLoader.loadWarehouses(supplierId),
        loadSpreadsheetAndCatalogItems(categoryPath, userId, supplierId, retailerId, gzippedFile, s3Path),
    ] as const);

    if (!(dscoSpreadsheet instanceof DscoSpreadsheet)) {
        return Err(dscoSpreadsheet);
    }

    if (!supplierSpreadsheet) {
        return Ok({
            totalRowCount: 0,
            categoryPath,
        });
    }

    // Pull the row data from the google spreadsheet
    const catalogRows = supplierSpreadsheet.extractCatalogRows(
        dscoSpreadsheet,
        supplierId,
        retailerId,
        categoryPath,
        keyWith(existingCatalogItems, (item) => [item.sku!, item]),
        warehouses,
    );

    // Resolve the rows that were modified, giving progress updates
    const resolver = new CatalogResolver(supplierId, userId);

    const skippedRows = new Set(skippedRowIndexes);

    const totalRowCount = supplierSpreadsheet.numDataRows();
    let remainingRowsToValidate = totalRowCount;

    // Enumerate all of the rows starting at 1 for the header.  Then filter out the skipped rows, rows without data, and unmodified rows
    const rowsToSave = filter(enumerate(catalogRows, 1), ([row, rowIdx]) => {
        const needsSave = !row.emptyRow && row.modified && !skippedRows.has(rowIdx);

        if (!needsSave) {
            remainingRowsToValidate -= 1;
        }

        return needsSave;
    });

    let batchSize = 20;
    if (remainingRowsToValidate > 5_000) {
        batchSize = 100;
    }

    const numConcurrentGearmanCalls = 15;
    const startValidationPct = randomFloat(0.45, 0.55);

    // Send batches of {batchSize} items to gearman at once
    const resolvedBatches = map(batch(rowsToSave, batchSize), (rows) => resolver.resolveBatch(rows));

    // Batch the gearman calls to run as many as we can concurrently
    const gearmanCalls = map(batch(resolvedBatches, numConcurrentGearmanCalls), (gearmanCalls) => Promise.all(collect(gearmanCalls)));

    await sendProgress(startValidationPct, `Validating ${remainingRowsToValidate} modified rows...`);

    for await (const resolvedBatch of gearmanCalls) {
        for (const resolvedBatchError of resolvedBatch) {
            if (resolvedBatchError) {
                await publishResultIfFanatics({
                    success: false,
                    rowWithError: resolvedBatchError.rowIdx,
                    validationMessages: resolvedBatchError.messages,
                }, supplierId);

                return Ok({
                    totalRowCount,
                    validationMessages: resolvedBatchError.messages,
                    rowWithError: resolvedBatchError.rowIdx,
                    sentRequest: await gzipAsync(Buffer.from(JSON.stringify(resolvedBatchError.sentRequest), 'utf8')),
                    categoryPath,
                });
            } else {
                remainingRowsToValidate -= batchSize;

                // Can happen if skipped rows.
                if (remainingRowsToValidate < 0) {
                    remainingRowsToValidate = 0;
                }
            }
        }

        const validationPct = (totalRowCount - remainingRowsToValidate) / totalRowCount;

        await sendProgress(
          (1 - startValidationPct) * validationPct + startValidationPct,
          `Validating ${numberWithCommas(remainingRowsToValidate)} rows...`,
        );

        console.log(`${callId} - Finished processing ${numberWithCommas(totalRowCount - remainingRowsToValidate)} out of ${numberWithCommas(totalRowCount)} rows...`);
    }

    console.log(`${callId} - Finished!`);

    await publishResultIfFanatics({
        success: true,
        numUploadedItems: totalRowCount
    }, supplierId);

    return Ok({ totalRowCount, categoryPath });
}

/**
 * For every sku in the spreadsheet, we try loading the existing catalog items.  This allows us to merge uploaded data with existing catalog data, and detect which rows have changed
 */
async function loadSpreadsheetAndCatalogItems(categoryPath: string, userId: number, supplierId: number, retailerId: number, gzippedFile?: string, s3Path?: string): Promise<[PhysicalSpreadsheet | undefined, CoreCatalog[]]> {
    let buffer;
    if (gzippedFile) {
        buffer = await gunzipAsync(gzippedFile);
    } else if (s3Path) {
        buffer = await downloadS3Bucket(s3Path);
    } else {
        throw new Error('Missing upload body');
    }

    const supplierSpreadsheet = XlsxSpreadsheet.isXlsx(buffer) ? XlsxSpreadsheet.fromBuffer(buffer) : new CsvSpreadsheet(buffer);

    return [
        supplierSpreadsheet,
        await catalogItemSearch(supplierId, retailerId, categoryPath, supplierSpreadsheet?.skus()),
    ];
}

/**
 * Fanatics is using an s3 bucket to communicate with us - this writes the results back to that bucket so they can pick it up
 */
async function publishResultIfFanatics(message: any, supplierId: number) {
    if (supplierId !== getFanaticsAccountForEnv()?.supplierId) {
        return;
    }

    await writeS3Object(getFanaticsBucketName(), `${getDscoEnv()}-result.json`, JSON.stringify(message));
}

// Purposely 10 seconds before actual timeout
const LAMBDA_TIMEOUT = 890 * 1_000;

// Resolves just before the lambda would time out.  This allows us to send it back to the user over the socket
function timeout(): Promise<'timeout'> {
    return new Promise((resolve) => {
        setTimeout(() => resolve('timeout'), LAMBDA_TIMEOUT);
    });
}

function numberWithCommas(x: number): string {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}
